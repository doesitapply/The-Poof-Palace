import requests
import json
import yaml
import uuid
import urllib.request
import urllib.parse
from typing import Dict, Any
import os
import time

class OllamaClient:
    """Client for interacting with a local Ollama instance."""
    def __init__(self, config):
        self.base_url = config['OLLAMA_API_BASE_URL']
        self.model = config['OLLAMA_MODEL']
        with open(config['LORE_BIBLE_PATH'], 'r') as f:
            self.lore_bible = f.read()

    def generate_text(self, system_prompt: str, user_prompt: str) -> str:
        full_prompt = f"{self.lore_bible}\n\n{user_prompt}"
        try:
            response = requests.post(
                f"{self.base_url}/api/chat",
                json={
                    "model": self.model,
                    "messages": [
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": full_prompt}
                    ],
                    "stream": False
                }
            )
            response.raise_for_status()
            # The actual content is in the 'content' field of the 'message' object
            return response.json()['message']['content'].strip()
        except requests.RequestException as e:
            print(f"Error communicating with Ollama: {e}")
            return "Error: Could not generate text."

class ComfyUIClient:
    """Client for interacting with a local ComfyUI instance via its API."""
    def __init__(self, config):
        self.base_url = config['COMFYUI_API_BASE_URL']
        self.config = config
        self.mock_mode = False

    def _check_comfyui_available(self) -> bool:
        """Check if ComfyUI is available and responding."""
        try:
            response = requests.get(f"{self.base_url}/system_stats", timeout=5)
            return response.status_code == 200
        except:
            return False

    def _create_mock_image(self, subject_prompt: str, output_path: str) -> bool:
        """Create a mock image file for testing purposes."""
        try:
            # Create a simple text file that represents the image
            mock_content = f"""
ðŸ° THE POOF PALACE - MOCK IMAGE ðŸ°
====================================

Subject: {subject_prompt}

This is a mock image file representing the whimsical storybook illustration
that would be generated by ComfyUI for The Poof Palace.

In a real setup, this would be a beautiful PNG image showing:
- Lil Poof in her royal glory
- Whimsical storybook style
- Soft golden lighting
- Warm, gentle colors
- The scene described in the prompt above

Generated by: The Poof Palace Autonomous Engine
Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}

ðŸ‘‘ Her Royal Floofiness awaits her portrait! ðŸ‘‘ðŸ±
"""
            
            # Save as a text file for now (in real setup, this would be a PNG)
            mock_path = output_path.replace('.png', '_mock.txt')
            with open(mock_path, 'w') as f:
                f.write(mock_content)
            
            print(f"Mock image saved to {mock_path}")
            print("ðŸ’¡ Note: This is a mock image. Install ComfyUI with models for real image generation.")
            return True
            
        except Exception as e:
            print(f"Error creating mock image: {e}")
            return False

    def _get_image_from_response(self, prompt_response: Dict[str, Any]) -> bytes:
        prompt_id = prompt_response['prompt_id']
        output_images = {}
        
        # Fetch history until we get the output
        while True:
            history_response = requests.get(f"{self.base_url}/history/{prompt_id}")
            history = history_response.json().get(prompt_id)
            if history and 'outputs' in history:
                for node_id in history['outputs']:
                    node_output = history['outputs'][node_id]
                    if 'images' in node_output:
                        for image_data in node_output['images']:
                            if image_data['type'] == 'output':
                                image_url = f"{self.base_url}/view?filename={image_data['filename']}&subfolder={image_data['subfolder']}&type={image_data['type']}"
                                with urllib.request.urlopen(image_url) as response:
                                    return response.read()
            # Add a small delay if not found yet
            import time
            time.sleep(1)

    def generate_image(self, subject_prompt: str, output_path: str) -> bool:
        # Check if ComfyUI is available
        if not self._check_comfyui_available():
            print("ComfyUI not available, using mock image generation...")
            return self._create_mock_image(subject_prompt, output_path)
        
        lora_name = self.config['COMFYUI_LORA_NAME']
        lora_strength = self.config['COMFYUI_LORA_STRENGTH']
        checkpoint = self.config['COMFYUI_CHECKPOINT_NAME']
        positive_prompt = f"<lora:{lora_name}:{lora_strength}>, {subject_prompt}, {self.config['POSITIVE_PROMPT_SUFFIX']}"
        
        # NOTE: This is a simplified workflow JSON. A real one would be more complex.
        # This assumes a basic LoadCheckpoint -> LoraLoader -> KSampler -> SaveImage workflow.
        # The user will need to export their actual workflow to JSON to get the correct structure.
        workflow_prompt = {
            "3": {
                "class_type": "KSampler",
                "inputs": {
                    "seed": 12345, # Should be randomized
                    "steps": 25,
                    "cfg": 7,
                    "sampler_name": "dpmpp_2m",
                    "scheduler": "karras",
                    "denoise": 1,
                    "model": ["14", 0],
                    "positive": ["6", 0],
                    "negative": ["7", 0],
                    "latent_image": ["5", 0]
                }
            },
            "4": {
                "class_type": "CheckpointLoaderSimple",
                "inputs": {"ckpt_name": checkpoint}
            },
            "5": {
                "class_type": "EmptyLatentImage",
                "inputs": {"width": 1024, "height": 1024, "batch_size": 1}
            },
            "6": {
                "class_type": "CLIPTextEncode",
                "inputs": {"text": positive_prompt, "clip": ["14", 1]}
            },
            "7": {
                "class_type": "CLIPTextEncode",
                "inputs": {"text": self.config['NEGATIVE_PROMPT'], "clip": ["14", 1]}
            },
            "9": {
                "class_type": "SaveImage",
                "inputs": {"filename_prefix": "PoofPalace", "images": ["3", 0]}
            },
            "14": {
                "class_type": "LoraLoader",
                "inputs": {
                    "lora_name": lora_name,
                    "strength_model": lora_strength,
                    "strength_clip": lora_strength,
                    "model": ["4", 0],
                    "clip": ["4", 1]
                }
            }
        }

        try:
            p = {"prompt": workflow_prompt, "client_id": str(uuid.uuid4())}
            data = json.dumps(p).encode('utf-8')
            req = urllib.request.Request(f"{self.base_url}/prompt", data=data)
            response = json.loads(urllib.request.urlopen(req).read())
            
            image_bytes = self._get_image_from_response(response)
            if image_bytes:
                with open(output_path, 'wb') as f:
                    f.write(image_bytes)
                print(f"Image saved to {output_path}")
                return True
            return False
        except Exception as e:
            print(f"Error communicating with ComfyUI: {e}")
            return False

# --- Scaffolded Social and Shopify Clients ---
class ShopifyClient:
    """Client for Shopify Store."""
    def __init__(self, config):
        # Initialization logic using ShopifyAPI library
        pass
    def get_popular_products(self):
        # Logic to get product data
        pass

class InstagramClient:
    """Client for Instagram Graph API."""
    def __init__(self, config):
        self.access_token = config['INSTAGRAM_ACCESS_TOKEN']
        self.user_id = config['INSTAGRAM_USER_ID']
        self.base_url = "https://graph.facebook.com/v18.0"
        
    def _is_configured(self) -> bool:
        """Check if Instagram API is properly configured."""
        return (self.access_token != "YOUR_INSTAGRAM_ACCESS_TOKEN" and 
                self.user_id != "YOUR_INSTAGRAM_USER_ID")
    
    def post_image(self, image_path: str, caption: str):
        """Post an image to Instagram using the Graph API."""
        if not self._is_configured():
            print(f"--- MOCK INSTAGRAM POST ---\nCaption: {caption}\nImage: {image_path}\n--------------------------")
            return False
            
        try:
            # For now, we'll use a known working image URL since Instagram requires public URLs
            # In production, you'd upload the image to a CDN or cloud storage first
            placeholder_image_url = "https://httpbin.org/image/jpeg"
            
            # Step 1: Create media container using the correct endpoint
            container_url = f"{self.base_url}/{self.user_id}/media"
            container_data = {
                'image_url': placeholder_image_url,
                'caption': caption,
                'access_token': self.access_token
            }
            
            print(f"Creating Instagram container with URL: {placeholder_image_url}")
            print(f"Container URL: {container_url}")
            
            container_response = requests.post(container_url, data=container_data)
            if container_response.status_code != 200:
                print(f"Instagram container creation failed: {container_response.text}")
                return False
                
            container_id = container_response.json().get('id')
            
            # Step 2: Publish the container
            publish_url = f"{self.base_url}/{self.user_id}/media_publish"
            publish_data = {
                'creation_id': container_id,
                'access_token': self.access_token
            }
            
            publish_response = requests.post(publish_url, data=publish_data)
            if publish_response.status_code == 200:
                print(f"âœ… Instagram post successful! ID: {publish_response.json().get('id')}")
                return True
            else:
                print(f"Instagram publish failed: {publish_response.text}")
                return False
                
        except Exception as e:
            print(f"Instagram posting error: {e}")
            return False

class TikTokClient:
    """Client for TikTok API."""
    def __init__(self, config):
        self.access_token = config['TIKTOK_ACCESS_TOKEN']
        self.client_key = config['TIKTOK_CLIENT_KEY']
        self.client_secret = config.get('TIKTOK_CLIENT_SECRET', '')
        self.base_url = "https://open-api.tiktok.com"
        
    def _is_configured(self) -> bool:
        """Check if TikTok API is properly configured."""
        return (self.access_token != "YOUR_TIKTOK_ACCESS_TOKEN" and 
                self.client_key != "YOUR_TIKTOK_CLIENT_KEY")
    
    def post_video(self, video_path: str, caption: str):
        """Post a video to TikTok using the Content Posting API."""
        if not self._is_configured():
            print(f"--- MOCK TIKTOK POST ---\nCaption: {caption}\nVideo: {video_path}\n--------------------------")
            return False
            
        try:
            # TikTok Content Posting API v1.3
            # Step 1: Initialize upload
            init_url = f"{self.base_url}/share/video/upload/"
            
            headers = {
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json"
            }
            
            # Step 1: Initialize upload
            init_data = {
                "source_info": {
                    "source": "FILE_UPLOAD",
                    "video_size": 0,  # Will be updated with actual file size
                    "chunk_size": 0,
                    "total_chunk_count": 1
                }
            }
            
            init_response = requests.post(init_url, headers=headers, json=init_data)
            
            if init_response.status_code != 200:
                print(f"TikTok upload initialization failed: {init_response.text}")
                # Fall back to mock mode
                print(f"--- MOCK TIKTOK POST ---\nCaption: {caption}\nVideo: {video_path}\n--------------------------")
                return False
            
            init_result = init_response.json()
            upload_url = init_result.get('data', {}).get('upload_url')
            
            if not upload_url:
                print("TikTok upload URL not received")
                # Fall back to mock mode
                print(f"--- MOCK TIKTOK POST ---\nCaption: {caption}\nVideo: {video_path}\n--------------------------")
                return False
            
            # Step 2: Upload video file
            # For now, we'll use a placeholder since we need real video files
            print(f"ðŸ“¹ TikTok video upload placeholder for: {video_path}")
            print(f"Upload URL: {upload_url}")
            
            # Step 3: Publish video
            publish_url = f"{self.base_url}/share/video/publish/"
            publish_data = {
                "post_info": {
                    "title": caption,
                    "description": caption,
                    "privacy_level": "MUTUAL_FOLLOW_FRIEND",
                    "disable_duet": False,
                    "disable_comment": False,
                    "disable_stitch": False,
                    "video_cover_timestamp_ms": 1000
                },
                "source_info": {
                    "source": "FILE_UPLOAD",
                    "video_size": 0,
                    "chunk_size": 0,
                    "total_chunk_count": 1
                }
            }
            
            publish_response = requests.post(publish_url, headers=headers, json=publish_data)
            
            if publish_response.status_code == 200:
                publish_result = publish_response.json()
                video_id = publish_result.get('data', {}).get('publish_id')
                print(f"âœ… TikTok video posted successfully! Video ID: {video_id}")
                return True
            else:
                print(f"TikTok video publish failed: {publish_response.text}")
                # Fall back to mock mode
                print(f"--- MOCK TIKTOK POST ---\nCaption: {caption}\nVideo: {video_path}\n--------------------------")
                return False
                
        except Exception as e:
            print(f"TikTok posting error: {e}")
            # Fall back to mock mode
            print(f"--- MOCK TIKTOK POST ---\nCaption: {caption}\nVideo: {video_path}\n--------------------------")
            return False

class TwitterClient:
    """Client for Twitter API v2."""
    def __init__(self, config):
        self.api_key = config['TWITTER_API_KEY']
        self.api_secret = config['TWITTER_API_SECRET']
        self.access_token = config['TWITTER_ACCESS_TOKEN']
        self.access_secret = config['TWITTER_ACCESS_SECRET']
        self.bearer_token = config.get('TWITTER_BEARER_TOKEN', '')
        self.base_url = "https://api.twitter.com/2"
        
        # Initialize tweepy client
        try:
            import tweepy
            self.tweepy_client = tweepy.Client(
                consumer_key=self.api_key,
                consumer_secret=self.api_secret,
                access_token=self.access_token,
                access_token_secret=self.access_secret,
                bearer_token=self.bearer_token
            )
        except ImportError:
            self.tweepy_client = None
        
    def _is_configured(self) -> bool:
        """Check if Twitter API is properly configured."""
        return (self.api_key != "YOUR_TWITTER_API_KEY" and 
                self.access_token != "YOUR_TWITTER_ACCESS_TOKEN")
    
    def _get_oauth_signature(self, method: str, url: str, params: dict) -> str:
        """Generate OAuth 1.0a signature for Twitter API."""
        import hmac
        import hashlib
        import urllib.parse
        import time
        import secrets
        import base64
        
        # OAuth parameters
        oauth_params = {
            'oauth_consumer_key': self.api_key,
            'oauth_token': self.access_token,
            'oauth_signature_method': 'HMAC-SHA1',
            'oauth_timestamp': str(int(time.time())),
            'oauth_nonce': secrets.token_urlsafe(32),
            'oauth_version': '1.0'
        }
        
        # Combine all parameters
        all_params = {**oauth_params, **params}
        
        # Create signature base string
        base_string = f"{method}&{urllib.parse.quote(url, safe='')}&{urllib.parse.quote('&'.join([f'{k}={v}' for k, v in sorted(all_params.items())]), safe='')}"
        
        # Create signing key
        signing_key = f"{urllib.parse.quote(self.api_secret, safe='')}&{urllib.parse.quote(self.access_secret, safe='')}"
        
        # Generate signature
        signature = hmac.new(signing_key.encode(), base_string.encode(), hashlib.sha1).digest()
        oauth_signature = urllib.parse.quote(base64.b64encode(signature).decode(), safe='')
        
        return oauth_signature, oauth_params
    
    def post_tweet(self, text: str, image_path: str = None):
        """Post a tweet with optional image using Twitter API."""
        if not self._is_configured():
            print(f"--- MOCK TWITTER POST ---\nText: {text}\nImage: {image_path}\n--------------------------")
            return False
            
        try:
            # Use tweepy if available
            if self.tweepy_client:
                # Post tweet using tweepy
                response = self.tweepy_client.create_tweet(text=text)
                
                if response.data:
                    tweet_id = response.data['id']
                    print(f"âœ… Twitter post successful! Tweet ID: {tweet_id}")
                    return True
                else:
                    print("Twitter posting failed: No response data")
                    # Fall back to mock mode
                    print(f"--- MOCK TWITTER POST ---\nText: {text}\nImage: {image_path}\n--------------------------")
                    return False
            else:
                print("Tweepy not available, using mock mode")
                print(f"--- MOCK TWITTER POST ---\nText: {text}\nImage: {image_path}\n--------------------------")
                return False
                
        except Exception as e:
            print(f"Twitter posting error: {e}")
            # Fall back to mock mode
            print(f"--- MOCK TWITTER POST ---\nText: {text}\nImage: {image_path}\n--------------------------")
            return False
    
    def _upload_media(self, image_path: str) -> str:
        """Upload media to Twitter and return media ID."""
        try:
            # For now, we'll use a placeholder since we need a real image
            # In production, you'd upload the actual image file
            print(f"ðŸ“¸ Media upload placeholder for: {image_path}")
            return None  # Return None for now since we're using placeholder images
        except Exception as e:
            print(f"Media upload error: {e}")
            return None
